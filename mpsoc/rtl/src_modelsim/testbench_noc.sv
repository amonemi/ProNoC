`include "pronoc_def.v"
`ifdef SIMULATION

`define STND_DEV_EN

module testbench_noc;
    
    import pronoc_pkg::*;
    
    `define INCLUDE_SIM_PARAM
    `include "sim_param.sv" //will be generated by ProNoC GUI
    // simulation parameter setting
    // injected packet class percentage
    localparam 
        C0_p=100,
        C1_p=0,
        C2_p=0,
        C3_p=0;
    
    localparam RATIOw=$clog2(100);
    
    reg     reset ,clk;
    reg     start,stop;
    wire    sent_done;
    reg    done;
    reg [RATIOw-1:0] ratio;
    
    initial begin 
        clk = 1'b0;
        forever clk = #10 ~clk;
    end 
    
    initial begin 
    `ifdef ACTIVE_LOW_RESET_MODE 
        reset = 1'b0;
    `else 
        reset = 1'b1;
    `endif  
        start = 1'b0;
        stop  = 1'b0;
        ratio =INJRATIO;
        #80
        @(posedge clk) reset = ~reset;
        #200
        @(posedge clk) start = 1'b1;
        @(posedge clk) start = 1'b0;
        @(posedge sent_done) 
        stop=1;//stop all packet injectprs
        @(posedge done) //wait for all sent flits to be received at their destination
        #450
        @(posedge clk)
        $stop;
    end
    
    localparam     
        PCK_CNTw=   $clog2(MAX_PCK_NUM+1),
        CLK_CNTw=   $clog2(MAX_SIM_CLKs+1),
        AVG_PCK_SIZ = (MAX_PACKET_SIZE + MIN_PACKET_SIZE)/2 ;
        
    typedef struct  {
        logic [PCK_CNTw-1 :0] pck_num;
        integer flit_num;
        integer worst_latency;
        integer min_latency;
        real sum_clk_h2h;
        real sum_clk_h2t;
        real sum_clk_per_hop;
    `ifdef STND_DEV_EN
        real sum_clk_pow2;
    `endif
    } statistic_t;
    
    typedef struct  { 
        real avg_latency_per_hop;
        real avg_latency_flit;
        real avg_latency_pck;
        real avg_throughput;
        real avg_pck_siz;
    `ifdef STND_DEV_EN
        real std_dev;
    `endif
    } avg_st_t;
    
    integer m,c;
    localparam STAT_NUM= (C==0)? 1 : C;
    statistic_t sent_stat [NE][STAT_NUM];
    statistic_t rsvd_stat [NE][STAT_NUM];    
    statistic_t sent_stat_class [NE];
    statistic_t rsvd_stat_class [NE];
    statistic_t sent_stat_per_class [STAT_NUM];
    statistic_t rsvd_stat_per_class [STAT_NUM];
    statistic_t rsvd_stat_total;
    statistic_t sent_stat_total;
    statistic_t endp_to_endp[NE][NE];
    
    task  update_rsvd_st(
        inout statistic_t rsvd_stat,
        input int clk_num_h2h,
        input int clk_num_h2t,
        input int latency,
        input int distance//,
        //input int pck_size
    );
    begin
        rsvd_stat.pck_num++;
        //rsvd_stat.flit_num += pck_size;
        rsvd_stat.sum_clk_h2h += real'(clk_num_h2h);
        rsvd_stat.sum_clk_h2t += real'(clk_num_h2t);
        rsvd_stat.sum_clk_per_hop += (distance != 0) ? (real'(clk_num_h2h) / real'(distance)) : 0.0;
        rsvd_stat.worst_latency = (rsvd_stat.worst_latency < latency) ? latency : rsvd_stat.worst_latency;
        if (rsvd_stat.min_latency == 0 || rsvd_stat.min_latency > latency) begin
            rsvd_stat.min_latency = latency;
        end
        `ifdef STND_DEV_EN
        rsvd_stat.sum_clk_pow2 += real'(clk_num_h2h) * real'(clk_num_h2h);
        `endif
    end
    endtask
    
    task print_endp_to_endp_st(string st);
    $write("\n\tEndp_to_Endp %s:\n\t#EID,", st);    
    // Print header row
    for (int src = 0; src < NE; src++) 
        $write("%0d,", src);
    $display("");
    // Print data rows
    for (int src = 0; src < NE; src++) begin
        $write("\t%0d,", src);
        for (int dst = 0; dst < NE; dst++) begin
            if (st == "pck_num") 
                $write("%0d,", endp_to_endp[src][dst].pck_num);
            else if (st == "flit_num") 
                $write("%0d,", endp_to_endp[src][dst].flit_num);
        end
        $display("");
    end
    endtask
    
    task update_send_st (
        inout statistic_t sent_stat,
        input int latency
    );
    begin
        sent_stat.worst_latency = (sent_stat.worst_latency < latency) ? latency : sent_stat.worst_latency;
        if ((sent_stat.min_latency == 0)  || (sent_stat.min_latency > latency)) begin 
            sent_stat.min_latency = latency;
        end
    end
    endtask
    
    initial begin 
        reset_st (rsvd_stat_total);
        reset_st (sent_stat_total);
        for(m=0;m<NE;m++) begin
            for (c=0;c<STAT_NUM;c++)begin
                reset_st(sent_stat[m][c]);
                reset_st(rsvd_stat[m][c]);
            end
            reset_st(rsvd_stat_class[m]);
            reset_st(sent_stat_class[m]);
            for (c=0;c<NE;c++)begin
                reset_st(endp_to_endp[m][c]);
            end
        end
        for (c=0; c<STAT_NUM;c++)begin 
            reset_st(sent_stat_per_class [c]);
            reset_st(rsvd_stat_per_class [c]);
        end            
    end
    
    task  reset_st;
        output  statistic_t stat_in;
        begin
            stat_in.pck_num={PCK_CNTw{1'b0}};
            stat_in.flit_num=0;
            stat_in.worst_latency=0;
            stat_in.min_latency=0;
            stat_in.sum_clk_h2h=0;
            stat_in.sum_clk_h2t=0;
            stat_in.sum_clk_per_hop=0;
    `ifdef STND_DEV_EN
            stat_in.sum_clk_pow2=0;
    `endif
        end
    endtask
    
    reg print_router_st;
    smartflit_chanel_t chan_in_all  [NE-1 : 0];
    smartflit_chanel_t chan_out_all [NE-1 : 0];
    router_event_t router_event [NR-1 : 0] [MAX_P-1 : 0];
    
    wire [NE-1 : 0] hdr_flit_sent;
    wire [DAw-1 : 0] dest_e_addr [NE-1 : 0];  
    wire [EAw-1 : 0] src_e_addr [NE-1 : 0]; 
    wire [Cw-1 : 0] pck_class_in [NE-1 : 0]; 
    wire [Cw-1 : 0] flit_out_class [NE-1 : 0]; 
    wire [NEw-1 : 0] src_id [NE-1 : 0]; 
    
    wire [PCK_SIZw-1: 0] pck_size_in [NE-1 :0]; 
    wire [PCK_SIZw-1: 0] pck_size_o  [NE-1 :0];   
    wire [NEw-1 : 0] mcast_dst_num [NE-1 :0];   
    
    //   wire    [NE-1 :0] report;
    reg     [CLK_CNTw-1 :0] clk_counter;
    wire    [PCK_CNTw-1 :0] pck_counter     [NE-1 :0];
    wire    [NE-1 :0] noc_report;
    wire    [NE-1 :0] update;
    wire    [CLK_CNTw-1 :0] time_stamp_h2t  [NE-1 :0];
    wire    [CLK_CNTw-1 :0] time_stamp_h2h  [NE-1 :0];
    wire    [DISTw-1 :0] distance        [NE-1 :0];    
    wire    [Cw-1 :0] pck_class_out       [NE-1 :0];    
    reg                         count_en;
    //reg [NE-1 : 0] start_o;
    logic [DELAYw-1 : 0] start_delay [NE-1 : 0];
    
    always @(`pronoc_clk_reset_edge) begin 
        if (`pronoc_reset) begin 
            count_en <=1'b0;
        end else begin 
            if(start) count_en <=1'b1;
            else if(noc_report) count_en <=1'b0;
        end 
    end//always
    
    noc_top  the_noc (
        .reset(reset),
        .clk(clk),
        .chan_in_all(chan_in_all),
        .chan_out_all(chan_out_all),
        .router_event(router_event)
    );
    
    always @ (`pronoc_clk_reset_edge)begin 
        if (`pronoc_reset  ) begin clk_counter  <= 0;  end
        else  begin 
            if  (count_en) clk_counter  <= clk_counter+1'b1;    
            
        end
    end
    
    function integer addrencode;
        input integer pos,k,n,kw;
        integer pow,i,tmp;begin
            addrencode=0;
            pow=1;
            for (i = 0; i <n; i=i+1 ) begin 
                tmp=(pos/pow);
                tmp=tmp%k;
                tmp=tmp<<i*kw;
                addrencode=addrencode | tmp;
                pow=pow * k;
            end
        end   
    endfunction 
    
    genvar i;
    wire [NE-1 : 0] valid_dst;
    wire [EAw-1 : 0] current_e_addr [NE-1 : 0];
    generate 
    for(i=0; i< NE; i=i+1) begin : endpoints
        endp_addr_encoder #(
            .TOPOLOGY(TOPOLOGY),
            .T1(T1),
            .T2(T2),
            .T3(T3),
            .EAw(EAw),
            .NE(NE)
        ) encoder (
            .id(i[NEw-1 : 0]),
            .code(current_e_addr[i])
        );
        
        traffic_gen_top #(
            .MAX_RATIO(100),
            .ENDP_ID(i)
        ) the_traffic_gen (
            .ratio (ratio),
            .pck_size_in(pck_size_in[i]),
            .current_e_addr(current_e_addr[i]),
            .dest_e_addr(dest_e_addr[i]),
            .pck_class_in(pck_class_in[i]),  
            .init_weight({{(WEIGHTw-1){1'b0}},1'b1}),
            .hdr_flit_sent(hdr_flit_sent[i]),
            .pck_number(pck_counter[i]),
            .reset(reset),
            .clk(clk),
            .start(start),
            .stop(stop | ~valid_dst[i]),
            .sent_done(),
            .update(update[i]),
            .time_stamp_h2h(time_stamp_h2h[i]),
            .time_stamp_h2t(time_stamp_h2t[i]),
            .distance(distance[i]),
            .src_e_addr(src_e_addr[i] ),
            .pck_class_out(pck_class_out[i]),
            .report (1'b0),
            .pck_size_o(pck_size_o[i]),
            .chan_in(chan_out_all[i]),
            .chan_out(chan_in_all[i]),
            .start_delay(start_delay[i]),
            .flit_out_class(flit_out_class[i]),
            .flit_out_wr(),
            .flit_in_wr(),
            .mcast_dst_num_o(mcast_dst_num[i])
        );
        
        endp_addr_decoder #(
            .TOPOLOGY(TOPOLOGY),
            .T1(T1),
            .T2(T2),
            .T3(T3),
            .EAw(EAw),
            .NE(NE)
        ) decoder (
            .id(src_id[i]),
            .code(src_e_addr[i])
        );    
        
        pck_class_in_gen #(
            .C(C),
            .C0_p(C0_p),
            .C1_p(C1_p),
            .C2_p(C2_p),
            .C3_p(C3_p)
        )
        the_pck_class_in_gen
        (
            .en(hdr_flit_sent[i]),
            .pck_class_o(pck_class_in[i]),
            .reset(reset),
            .clk(clk)
        );
        
        pck_dst_gen #(
            .TRAFFIC(TRAFFIC),
            .HOTSPOT_NODE_NUM(HOTSPOT_NODE_NUM),
            .MCAST_TRAFFIC_RATIO(MCAST_TRAFFIC_RATIO),
            .MCAST_PCK_SIZ_MIN(MCAST_PCK_SIZ_MIN),
            .MCAST_PCK_SIZ_MAX(MCAST_PCK_SIZ_MAX),
            .MIN_PACKET_SIZE(MIN_PACKET_SIZE),
            .MAX_PACKET_SIZE(MAX_PACKET_SIZE),
            .PCK_SIZ_SEL(PCK_SIZ_SEL),
            .DISCRETE_PCK_SIZ_NUM(DISCRETE_PCK_SIZ_NUM)
        ) the_pck_dst_gen (
            .reset(reset),
            .clk(clk),
            .en(hdr_flit_sent[i]),
            .core_num(i[NEw-1 : 0]),
            .pck_number(pck_counter[i]),
            .current_e_addr(current_e_addr[i]),
            .dest_e_addr(dest_e_addr[i]),
            .valid_dst(valid_dst[i]),
            .hotspot_info(hotspot_info),
            .pck_size_o( pck_size_in[i]) ,
            .rnd_discrete(rnd_discrete),
            .custom_traffic_t(custom_traffic_t[i]),  // defined in sim_param.sv
            .custom_traffic_en(custom_traffic_en[i])  // defined in sim_param.sv
        );
    end
    endgenerate
    
    real      sum_clk_h2h,sum_clk_h2t;
    real      sum_clk_pow2;
    real      sum_clk_pow2_per_class      [C-1 : 0];
    real      sum_clk_per_hop;
    integer   total_rsv_pck_num_per_class [C-1 : 0];
    real      sum_clk_h2h_per_class       [C-1 : 0];
    real      sum_clk_h2t_per_class       [C-1 : 0];
    real      sum_clk_per_hop_per_class   [C-1 : 0];
    integer   rsvd_core_total_rsv_pck_num [NE-1 : 0];
    integer   rsvd_core_worst_delay       [NE-1 : 0];
    integer   sent_core_worst_delay       [NE-1 : 0];
    integer   total_active_endp;
    integer   total_rsv_pck_num,total_rsv_flit_number;
    integer   total_sent_pck_num,total_sent_flit_number,total_expect_rsv_flit_num;
    integer   rsv_size_array [MAX_PACKET_SIZE - MIN_PACKET_SIZE : 0]; 
    integer core_num,k;
    integer latency_tmp,class_tmp,src_tmp;;
    
    always @(`pronoc_clk_reset_edge)begin
        if (`pronoc_reset) begin 
            total_rsv_pck_num=0;
            total_sent_pck_num=0;
            sum_clk_h2h=0;
            sum_clk_h2t=0;
            sum_clk_pow2=0;
            sum_clk_per_hop=0;
            total_sent_flit_number=0;
            total_rsv_flit_number=0;
            total_expect_rsv_flit_num=0;
            for (k=0;k<C;k=k+1) begin 
                sum_clk_pow2_per_class[k]=0;
                total_rsv_pck_num_per_class[k]=0;
                sum_clk_h2h_per_class [k]=0;
                sum_clk_h2t_per_class [k]=0;
                sum_clk_per_hop_per_class[k]=0;
            end
            for (k=0;k<NE;k=k+1) begin 
                rsvd_core_total_rsv_pck_num[k]=0;
                rsvd_core_worst_delay[k]=0;
                sent_core_worst_delay[k]=0;
            end
            for (k=0; k<= MAX_PACKET_SIZE - MIN_PACKET_SIZE; k++)     rsv_size_array[k]=0;
        end
        
        for (core_num=0; core_num<NE; core_num=core_num+1)begin 
            src_tmp = src_id[core_num];
            class_tmp = (C>1)? pck_class_out[core_num] : 0; 
            if(chan_in_all[core_num].flit_chanel.flit_wr)begin 
                total_sent_flit_number+=1;
                if (CAST_TYPE != "UNICAST") total_expect_rsv_flit_num+=mcast_dst_num[core_num];
                else   total_expect_rsv_flit_num++;
                if (C>1) sent_stat [core_num][flit_out_class[core_num]].flit_num++;
                else       sent_stat [core_num][0].flit_num++;
                if(chan_in_all[core_num].flit_chanel.flit[Fw-1])begin
                    total_sent_pck_num+=1;
                    if (C>1) sent_stat [core_num][flit_out_class[core_num]].pck_num++;
                    else       sent_stat [core_num][0].pck_num++;
                end        
            end
            if(chan_out_all[core_num].flit_chanel.flit_wr)begin 
                total_rsv_flit_number+=1;    
                endp_to_endp[src_tmp][core_num].flit_num++;
                rsvd_stat [core_num][class_tmp].flit_num++;
            end           
            if( update [core_num] ) begin 
                total_rsv_pck_num = total_rsv_pck_num+1;
                latency_tmp =(AVG_LATENCY_METRIC == "HEAD_2_TAIL")?
                            time_stamp_h2t[core_num]:time_stamp_h2h[core_num];                                
                update_rsvd_st(
                    rsvd_stat[core_num][class_tmp],
                    $itor(time_stamp_h2h[core_num]),//clk_num_h2h,
                    $itor(time_stamp_h2t[core_num]),//clk_num_h2t,
                    latency_tmp,
                    distance[core_num]
                );
                update_send_st(
                    sent_stat[src_tmp][class_tmp],
                    latency_tmp
                );
                update_rsvd_st( 
                    endp_to_endp[src_tmp][core_num],
                    $itor(time_stamp_h2h[core_num]),//clk_num_h2h,
                    $itor(time_stamp_h2t[core_num]),//clk_num_h2t,     
                    latency_tmp,
                    distance[core_num]
                );
                if((total_rsv_pck_num & 'hffff )==0 ) $display(" packet received total=%0d",total_rsv_pck_num);
                sum_clk_h2h +=  time_stamp_h2h[core_num];
                sum_clk_h2t +=  time_stamp_h2t[core_num];
                `ifdef STND_DEV_EN
                    sum_clk_pow2+=time_stamp_h2h[core_num] * time_stamp_h2h[core_num];
                    sum_clk_pow2_per_class[pck_class_out[core_num]]+=time_stamp_h2h[core_num] * time_stamp_h2h[core_num];
                `endif
                if(distance[core_num] > 0) sum_clk_per_hop+= $itor(time_stamp_h2h[core_num])/$itor(distance[core_num]);
                total_rsv_pck_num_per_class[pck_class_out[core_num]]+=1;
                sum_clk_h2h_per_class[pck_class_out[core_num]]+=time_stamp_h2h[core_num] ;
                sum_clk_h2t_per_class[pck_class_out[core_num]]+=time_stamp_h2t[core_num] ;
                if(distance[core_num]>0) sum_clk_per_hop_per_class[pck_class_out[core_num]]+= $itor(time_stamp_h2h[core_num])/$itor(distance[core_num]);
                rsvd_core_total_rsv_pck_num[core_num]+=1;
                if (rsvd_core_worst_delay[core_num] < time_stamp_h2t[core_num]) rsvd_core_worst_delay[core_num] = ( AVG_LATENCY_METRIC == "HEAD_2_TAIL")? time_stamp_h2t[core_num] : time_stamp_h2h[core_num];
                if (sent_core_worst_delay[src_id[core_num]] < time_stamp_h2t[core_num]) sent_core_worst_delay[src_id[core_num]] = (AVG_LATENCY_METRIC == "HEAD_2_TAIL")?  time_stamp_h2t[core_num] : time_stamp_h2h[core_num];
                if (pck_size_o[core_num] >= MIN_PACKET_SIZE && pck_size_o[core_num] <=MAX_PACKET_SIZE) rsv_size_array[pck_size_o[core_num]-MIN_PACKET_SIZE] = rsv_size_array[pck_size_o[core_num]-MIN_PACKET_SIZE]+1;
            end
        end
    end//always
    
    integer rsv_ideal_cnt,total_rsv_flit_number_old;
    reg all_done_reg;
    wire all_done_in;
    assign all_done_in = (clk_counter > STOP_SIM_CLK) || ( total_sent_pck_num >  STOP_PCK_NUM );
    assign sent_done = all_done_in & ~ all_done_reg;
    logic report_active_ivcs;
    always @(`pronoc_clk_reset_edge)begin
        if (`pronoc_reset) begin 
            all_done_reg <= 1'b0;
            rsv_ideal_cnt<=0;
            done<=1'b0;
            total_rsv_flit_number_old<=0;
            report_active_ivcs<='0;
        end  else  begin 
            all_done_reg <= all_done_in;
            total_rsv_flit_number_old<=total_rsv_flit_number;
            if(all_done_in) begin //All injectors stopped injecting packets 
                if(total_rsv_flit_number_old==total_rsv_flit_number) rsv_ideal_cnt<=rsv_ideal_cnt+1;//count the number of cycle when no flit is received by any injector  
                else rsv_ideal_cnt=0;
                if(total_expect_rsv_flit_num == total_rsv_flit_number) begin // All injected packets are consumed
                    done<=1'b1;
                end
                if(rsv_ideal_cnt >= 100) begin //  Injectors stopped sending packets, number of received and sent flits are not equal yet and for 100 cycles no flit is consumed. 
                    done<=1'b1;
                    #50;
                    report_active_ivcs<=1'b1;
                    #50;
                    $display ("ERROR: The number of expected (%d) & received flits (%d) were not equal at the end of simulation",total_expect_rsv_flit_num ,total_rsv_flit_number);
                    $stop;
                end
            end
        end
    end
    
    initial total_active_endp=0;
    real avg_throughput,avg_latency_flit,avg_latency_pck,std_dev,avg_latency_per_hop,min_avg_latency_per_class;
    
    initial begin 
        for(m=0;m<NE;m++) start_delay[m] =$urandom_range((2**DELAYw)-2,0);  
    end
    
    initial print_router_st=1'b0;
    
    //report 
    always @( posedge done) begin     
        for (core_num=0; core_num<NE; core_num=core_num+1) begin  
            if(pck_counter[core_num]>0) total_active_endp       =     total_active_endp +1;
        end
        avg_throughput= ((total_sent_flit_number*100)/total_active_endp )/clk_counter;
        avg_latency_flit =sum_clk_h2h/$itor(total_rsv_pck_num);
        avg_latency_pck     =sum_clk_h2t/$itor(total_rsv_pck_num);
        avg_latency_per_hop    = sum_clk_per_hop/$itor(total_rsv_pck_num);
        $display("\nsimulation results-------------------");
        $display("\tSimulation clock cycles:%0d",clk_counter);
        $display("\n\tTotal received packet in different size:");
        $write("\tflit_size,");
        for (m=0;m<=(MAX_PACKET_SIZE - MIN_PACKET_SIZE);m++) begin            
            if(rsv_size_array[m]>0)$write("%0d,",m+ MIN_PACKET_SIZE);
        end
        $write("\n\t#pck,");
        for (m=0;m<=(MAX_PACKET_SIZE - MIN_PACKET_SIZE);m++) begin            
            if(rsv_size_array[m]>0)$write("%0d,",rsv_size_array[m]);
        end        
        print_router_st=1'b1;
        #1
        // if(ratio==RATIO_INIT) first_avg_latency_flit=avg_latency_flit;
        //`ifdef STND_DEV_EN
                //std_dev= standard_dev( sum_clk_pow2,total_rsv_pck_num, avg_latency_flit);
                //$display(" standard_dev = %f",std_dev);
        //`endif
        print_endp_to_endp_st("pck_num");
        print_endp_to_endp_st("flit_num");
        $display("\n\n\tEndpoints Statistics:");
        $write("\t#EID,sent_stat.pck_num,rsvd_stat.pck_num,sent_stat.flit_num,rsvd_stat.flit_num,sent_stat.worst_latency,rsvd_stat.worst_latency,sent_stat.min_latency,rsvd_stat.min_latency,avg_latency_per_hop,avg_latency_flit,avg_latency_pck,avg_throughput(%%),avg_pck_size,");
        `ifdef STND_DEV_EN
        $write("avg.std_dev");
        `endif
        $write("\n");       
        for (m=0; m<NE;m++)begin
            for (c=0; c<STAT_NUM;c++)begin
                merge_statistic (rsvd_stat_class[m],rsvd_stat[m][c],rsvd_stat_class[m]);
                merge_statistic (sent_stat_class[m],sent_stat[m][c],sent_stat_class[m]);
                if(C>1) begin 
                    merge_statistic (rsvd_stat_per_class[c],rsvd_stat[m][c],rsvd_stat_per_class[c]);
                    merge_statistic (sent_stat_per_class[c],sent_stat[m][c],sent_stat_per_class[c]);
                end
            end
        end
        for (m=0; m<NE;m++)begin
            merge_statistic (rsvd_stat_total,rsvd_stat_class[m],rsvd_stat_total);
            merge_statistic (sent_stat_total,sent_stat_class[m],sent_stat_total);
        end
        $write("\ttotal,");
        print_st_single (clk_counter, rsvd_stat_total,sent_stat_total);
        if(C>1)begin
            for (c=0; c<C;c++)begin
                $write("\ttotal_class%0d,",c);
                print_st_single (clk_counter, rsvd_stat_per_class[c],sent_stat_per_class[c]);
            end
        end
        for (m=0; m<NE;m++)begin
            $write("\t%0d,",m);
            if(C>1) begin 
                    print_st_single (clk_counter, rsvd_stat_class[m],sent_stat_class[m] );
            end else begin 
                print_st_single (clk_counter, rsvd_stat[m][0],sent_stat[m][0] );
            end
        end        
    end //always
    
    initial begin
        display_noc_parameters();        
        $display ("Simulation parameters-------------");
        if(DEBUG_EN)
            $display ("\tDebuging is enabled");
        else
            $display ("\tDebuging is disabled");
        //if( AVG_LATENCY_METRIC == "HEAD_2_TAIL")  $display ("\tOutput is the average latency on sending the packet header until receiving tail");
        //else $display ("\tOutput is the average latency on sending the packet header until receiving header flit at destination node");
        $display ("\tTraffic pattern:%s",TRAFFIC);
        if(C>0) $display ("\ttraffic percentage of class 0 is : %0d", C0_p);
        if(C>1) $display ("\ttraffic percentage of class 1 is : %0d", C1_p);
        if(C>2) $display ("\ttraffic percentage of class 2 is : %0d", C2_p);
        if(C>3) $display ("\ttraffic percentage of class 3 is : %0d", C3_p);
        if(TRAFFIC == "HOTSPOT")begin
            //$display ("\tHot spot percentage: %u\n", HOTSPOT_PERCENTAGE);
            $display ("\tNumber of hot spot cores: %0d", HOTSPOT_NODE_NUM);
        end
        if (CAST_TYPE != "UNICAST")begin
            $display ("\tMULTICAST traffic ratio: %d(%%), min: %d, max: %d\n", MCAST_TRAFFIC_RATIO,MCAST_PCK_SIZ_MIN,MCAST_PCK_SIZ_MAX);
        end 
        //$display ("\tTotal packets sent by one router: %u\n", TOTAL_PKT_PER_ROUTER);
        $display ("\tSimulation timeout =%0d", STOP_SIM_CLK);
        $display ("\tSimulation ends on total packet num of =%0d", STOP_PCK_NUM);
        $display ("\tPacket size (min,max,average) in flits: (%0d,%0d,%0d)",MIN_PACKET_SIZE,MAX_PACKET_SIZE,AVG_PCK_SIZ);
        $display ("\tPacket injector FIFO width in flit:%0d",TIMSTMP_FIFO_NUM);
        $display ("\tFlit injection ratio per router is =%f (flits/clk/Total Endpoint %%)",ratio);
        $display ("Simulation parameters-------------");
    end//initial   
    
    task merge_statistic;
    input statistic_t merge_stat;
    input statistic_t stat_in;
    output statistic_t stat_out;
    begin 
        stat_out.pck_num =    merge_stat.pck_num+stat_in.pck_num;
        stat_out.flit_num =   merge_stat.flit_num+stat_in.flit_num;
        if(merge_stat.worst_latency <  stat_in.worst_latency) stat_out.worst_latency= stat_in.worst_latency;
        if(merge_stat.min_latency   == 0                       ) stat_out.min_latency  = stat_in.min_latency;
        if(merge_stat.min_latency   > stat_in.min_latency  && stat_in.min_latency!=0   ) stat_out.min_latency  = stat_in.min_latency;
        stat_out.sum_clk_h2h = merge_stat.sum_clk_h2h      +stat_in.sum_clk_h2h    ;
        stat_out.sum_clk_h2t = merge_stat.sum_clk_h2t      +stat_in.sum_clk_h2t    ;
        stat_out.sum_clk_per_hop =   merge_stat.sum_clk_per_hop  +stat_in.sum_clk_per_hop;
        `ifdef STND_DEV_EN
            stat_out.sum_clk_pow2 = merge_stat.sum_clk_pow2 +stat_in.sum_clk_pow2;
        `endif
    end
    endtask
    
    task print_st_single;
    input [CLK_CNTw-1 : 0]total_clk;
    input statistic_t rsvd_stat;
    input statistic_t sent_stat;
    begin 
        avg_st_t avg;
        finilize_statistic (total_clk,  rsvd_stat, avg);
        $write("%0d,",sent_stat.pck_num);
        $write("%0d,",rsvd_stat.pck_num);
        $write("%0d,",sent_stat.flit_num);
        $write("%0d,",rsvd_stat.flit_num);
        $write("%0d,",sent_stat.worst_latency);
        $write("%0d,",rsvd_stat.worst_latency);
        $write("%0d,",sent_stat.min_latency);
        $write("%0d,",rsvd_stat.min_latency);
        $write("%f,",avg.avg_latency_per_hop);
        $write("%f,",avg.avg_latency_flit);
        $write("%f,",avg.avg_latency_pck);
        $write("%f,",avg.avg_throughput);
        $write("%f,",avg.avg_pck_siz);
        `ifdef STND_DEV_EN
        $write("%f,",avg.std_dev);
        `endif
        $write("\n");
    end
    endtask
    
    task finilize_statistic;
    input [CLK_CNTw-1 : 0]total_clk;
    input statistic_t rsvd_stat;
    output avg_st_t avg_statistic;
    begin   
        avg_statistic.avg_throughput = ($itor(rsvd_stat.flit_num*100)/NE )/total_clk;
        avg_statistic.avg_latency_flit =(rsvd_stat.pck_num>0)? rsvd_stat.sum_clk_h2h/rsvd_stat.pck_num : 0;
        avg_statistic.avg_latency_pck = (rsvd_stat.pck_num>0)? rsvd_stat.sum_clk_h2t/rsvd_stat.pck_num :0;
        avg_statistic.avg_latency_per_hop = ( rsvd_stat.pck_num==0)? 0 : rsvd_stat.sum_clk_per_hop/rsvd_stat.pck_num;
        avg_statistic.avg_pck_siz  = ( rsvd_stat.pck_num==0)? 0 : $itor(rsvd_stat.flit_num) / $itor(rsvd_stat.pck_num);
        `ifdef STND_DEV_EN
            standard_dev( rsvd_stat.sum_clk_pow2,rsvd_stat.pck_num, avg_statistic.avg_latency_flit,avg_statistic.std_dev);
        `endif
    end
    endtask
    
    `ifdef STND_DEV_EN
    /************************
     * std_dev = sqrt[(B-A^2/N)/N]  = sqrt [(B/N)- (A/N)^2] = sqrt [B/N - mean^2]
     * A = sum of the values
     * B = sum of the squarded values 
     * *************/
    task standard_dev;
    input real sum_pow2;
    input [PCK_CNTw-1 :0]  total_num;
    input real average;
    output real std_dev;
    begin
        /*
        double  A, B, N;
        N= total_num;
        A= average * N;
        B= sum_pow2;
        A=(A*A)/N;
        std_dev = (B-A)/N;
        std_dev = sqrt(std_dev);
        */    
        if(total_num==0) std_dev= 0;
        else begin
            std_dev = sum_pow2/$itor(total_num); //B/N
            std_dev -= (average*average);// (B/N) - mean^2
            std_dev = $sqrt(std_dev);// sqrt [B/N - mean^2]
        end
    end
    endtask
    `endif
    
    /*
    start_delay_gen #(
            .NC(NE)
        )
        delay_gen
        (
            .clk(clk),
            .reset(reset),
            .start_i(start),
            .start_o(start_o)
        );
     */

    routers_statistic_collector router_stat ( 
        .reset(reset),
        .clk(clk),        
        .router_event(router_event),
        .print(print_router_st)
    );
    
endmodule
`endif
