#######################################################################
##	File: ni_master.IP
##    
##	Copyright (C) 2014-2019  Alireza Monemi
##    
##	This file is part of ProNoC 1.9.1 
##
## 	WARNING: THIS IS AN AUTO-GENERATED FILE. CHANGES TO IT 
##	MAY CAUSE UNEXPECTED BEHAVIOR.
################################################################################

$ipgen = bless( {
                  'ports_order' => [
                                     'reset',
                                     'clk',
                                     'current_e_addr',
                                     'current_r_addr',
                                     'chan_out',
                                     'chan_in',
                                     's_dat_i',
                                     's_sel_i',
                                     's_addr_i',
                                     's_cti_i',
                                     's_stb_i',
                                     's_cyc_i',
                                     's_we_i',
                                     's_dat_o',
                                     's_ack_o',
                                     'm_send_sel_o',
                                     'm_send_addr_o',
                                     'm_send_cti_o',
                                     'm_send_stb_o',
                                     'm_send_cyc_o',
                                     'm_send_we_o',
                                     'm_send_dat_i',
                                     'm_send_ack_i',
                                     'm_receive_sel_o',
                                     'm_receive_dat_o',
                                     'm_receive_addr_o',
                                     'm_receive_cti_o',
                                     'm_receive_stb_o',
                                     'm_receive_cyc_o',
                                     'm_receive_we_o',
                                     'm_receive_ack_i',
                                     'irq'
                                   ],
                  'parameters' => {
                                    'CRC_EN' => {
                                                  'redefine_param' => 1,
                                                  'default' => '"NO"',
                                                  'global_param' => 'Localparam',
                                                  'info' => 'The parameter can be selected as "YES" or "NO". 
If CRC is enabled, then two CRC32 generator modules will be added to the NI. One CRC generator for calculating CRC of sending packets and another for receiving packets.   The CRC32 value of each packet is send via tail flit and at destination NI, is will be compared with received packet generated CRC32. The matching results can be used for error-detection and can be read via NI slave interface. ',
                                                  'content' => '"YES","NO"',
                                                  'type' => 'Combo-box'
                                                },
                                    'SELw' => {
                                                'info' => 'Parameter',
                                                'content' => '',
                                                'global_param' => 'Localparam',
                                                'redefine_param' => 1,
                                                'default' => '4',
                                                'type' => 'Fixed'
                                              },
                                    'MAX_TRANSACTION_WIDTH' => {
                                                                 'type' => 'Spin-button',
                                                                 'global_param' => 'Localparam',
                                                                 'redefine_param' => 1,
                                                                 'default' => '13',
                                                                 'info' => 'maximum packet size width  in words.
The maximum data that can be sent via one packet will be 2 power of MAX_DMA_TRANSACTION_WIDTH in words.',
                                                                 'content' => '4,32,1'
                                                               },
                                    'EAw' => {
                                               'type' => 'Fixed',
                                               'default' => '16',
                                               'redefine_param' => 0,
                                               'global_param' => 'Parameter',
                                               'content' => '',
                                               'info' => undef
                                             },
                                    'S_Aw' => {
                                                'type' => 'Fixed',
                                                'content' => '',
                                                'info' => 'Parameter',
                                                'default' => '8',
                                                'redefine_param' => 1,
                                                'global_param' => 'Localparam'
                                              },
                                    'TAGw' => {
                                                'type' => 'Fixed',
                                                'global_param' => 'Localparam',
                                                'redefine_param' => 1,
                                                'default' => '3',
                                                'info' => 'Parameter',
                                                'content' => ''
                                              },
                                    'Dw' => {
                                              'info' => 'wishbone_bus data width in bits.',
                                              'content' => '32,256,8',
                                              'global_param' => 'Localparam',
                                              'default' => '32',
                                              'redefine_param' => 1,
                                              'type' => 'Spin-button'
                                            },
                                    'M_Aw' => {
                                                'type' => 'Fixed',
                                                'info' => 'Parameter',
                                                'content' => 'Dw',
                                                'redefine_param' => 1,
                                                'default' => '32',
                                                'global_param' => 'Localparam'
                                              },
                                    'MAX_BURST_SIZE' => {
                                                          'default' => '16',
                                                          'redefine_param' => 1,
                                                          'global_param' => 'Localparam',
                                                          'info' => 'Maximum burst size in words. 
The NI releases the wishbone bus  each time one burst is completed or when the VC\'s internal FIFO becomes full.  The bus will be released for one clock cycle. Then in case, there are other active VCs, another active VC will get access to the bus using round robin arbiter.  This process will be continued until all of the desired data is transferred. ',
                                                          'content' => '2,4,8,16,32,64,128,256,512,1024,2048',
                                                          'type' => 'Combo-box'
                                                        },
                                    'RAw' => {
                                               'type' => 'Fixed',
                                               'redefine_param' => 0,
                                               'default' => '16',
                                               'global_param' => 'Parameter',
                                               'content' => '',
                                               'info' => undef
                                             },
                                    'HDATA_PRECAPw' => {
                                                         'type' => 'Spin-button',
                                                         'info' => ' The headr Data pre capture width. It Will be enabled when it is larger than zero. The header data can optionally carry a short width Data. This data can be pre-captured (completely/partially) by the NI before saving the packet in a memory buffer. This can give some hints to the software regarding the incoming packet such as its type, or source port so the software can store the packet in its appropriate buffer.',
                                                         'content' => '0,8,1',
                                                         'global_param' => 'Localparam',
                                                         'default' => '0',
                                                         'redefine_param' => 1
                                                       }
                                  },
                  'plugs' => {
                               'reset' => {
                                            'type' => 'num',
                                            'value' => 1,
                                            '0' => {
                                                     'name' => 'reset'
                                                   },
                                            'reset' => {}
                                          },
                               'wb_slave' => {
                                               'type' => 'num',
                                               '0' => {
                                                        'name' => 'wb_slave',
                                                        'addr' => '0xb800_0000	0xbfff_ffff		custom devices',
                                                        'width' => 10
                                                      },
                                               'wb_slave' => {},
                                               'value' => 1
                                             },
                               'wb_master' => {
                                                '1' => {
                                                         'name' => 'wb_receive'
                                                       },
                                                'wb_master' => {},
                                                'type' => 'num',
                                                '0' => {
                                                         'name' => 'wb_send'
                                                       },
                                                'value' => 2
                                              },
                               'interrupt_peripheral' => {
                                                           'value' => 1,
                                                           '0' => {
                                                                    'name' => 'interrupt'
                                                                  },
                                                           'type' => 'num',
                                                           'interrupt_peripheral' => {}
                                                         },
                               'clk' => {
                                          'clk' => {},
                                          'type' => 'num',
                                          '0' => {
                                                   'name' => 'clk'
                                                 },
                                          'value' => 1
                                        }
                             },
                  'ports' => {
                               'm_send_stb_o' => {
                                                   'intfc_port' => 'stb_o',
                                                   'range' => '',
                                                   'type' => 'output',
                                                   'intfc_name' => 'plug:wb_master[0]'
                                                 },
                               'm_send_cti_o' => {
                                                   'range' => 'TAGw-1          :   0',
                                                   'intfc_port' => 'cti_o',
                                                   'intfc_name' => 'plug:wb_master[0]',
                                                   'type' => 'output'
                                                 },
                               'chan_in' => {
                                              'range' => 'smartflit_chanel_t',
                                              'intfc_port' => 'chan_in',
                                              'type' => 'input',
                                              'intfc_name' => 'socket:ni[0]'
                                            },
                               'm_receive_sel_o' => {
                                                      'type' => 'output',
                                                      'intfc_name' => 'plug:wb_master[1]',
                                                      'range' => 'SELw-1          :   0',
                                                      'intfc_port' => 'sel_o'
                                                    },
                               'm_send_sel_o' => {
                                                   'intfc_port' => 'sel_o',
                                                   'range' => 'SELw-1          :   0',
                                                   'type' => 'output',
                                                   'intfc_name' => 'plug:wb_master[0]'
                                                 },
                               'current_e_addr' => {
                                                     'intfc_name' => 'socket:ni[0]',
                                                     'type' => 'input',
                                                     'intfc_port' => 'current_e_addr',
                                                     'range' => 'EAw-1   :   0'
                                                   },
                               'chan_out' => {
                                               'type' => 'output',
                                               'intfc_name' => 'socket:ni[0]',
                                               'intfc_port' => 'chan_out',
                                               'range' => 'smartflit_chanel_t'
                                             },
                               'm_send_we_o' => {
                                                  'intfc_name' => 'plug:wb_master[0]',
                                                  'type' => 'output',
                                                  'intfc_port' => 'we_o',
                                                  'range' => ''
                                                },
                               's_cyc_i' => {
                                              'intfc_name' => 'plug:wb_slave[0]',
                                              'type' => 'input',
                                              'range' => '',
                                              'intfc_port' => 'cyc_i'
                                            },
                               'irq' => {
                                          'intfc_name' => 'plug:interrupt_peripheral[0]',
                                          'type' => 'output',
                                          'range' => '',
                                          'intfc_port' => 'int_o'
                                        },
                               'm_receive_ack_i' => {
                                                      'intfc_port' => 'ack_i',
                                                      'range' => '',
                                                      'intfc_name' => 'plug:wb_master[1]',
                                                      'type' => 'input'
                                                    },
                               'reset' => {
                                            'range' => '',
                                            'intfc_port' => 'reset_i',
                                            'intfc_name' => 'plug:reset[0]',
                                            'type' => 'input'
                                          },
                               'clk' => {
                                          'intfc_name' => 'plug:clk[0]',
                                          'type' => 'input',
                                          'intfc_port' => 'clk_i',
                                          'range' => ''
                                        },
                               'm_receive_addr_o' => {
                                                       'intfc_name' => 'plug:wb_master[1]',
                                                       'type' => 'output',
                                                       'intfc_port' => 'adr_o',
                                                       'range' => 'M_Aw-1          :   0'
                                                     },
                               's_dat_o' => {
                                              'type' => 'output',
                                              'intfc_name' => 'plug:wb_slave[0]',
                                              'range' => 'Dw-1       :   0',
                                              'intfc_port' => 'dat_o'
                                            },
                               'm_receive_cyc_o' => {
                                                      'type' => 'output',
                                                      'intfc_name' => 'plug:wb_master[1]',
                                                      'range' => '',
                                                      'intfc_port' => 'cyc_o'
                                                    },
                               'm_receive_we_o' => {
                                                     'range' => '',
                                                     'intfc_port' => 'we_o',
                                                     'intfc_name' => 'plug:wb_master[1]',
                                                     'type' => 'output'
                                                   },
                               'm_receive_dat_o' => {
                                                      'type' => 'output',
                                                      'intfc_name' => 'plug:wb_master[1]',
                                                      'intfc_port' => 'dat_o',
                                                      'range' => 'Dw-1            :   0'
                                                    },
                               's_dat_i' => {
                                              'intfc_name' => 'plug:wb_slave[0]',
                                              'type' => 'input',
                                              'intfc_port' => 'dat_i',
                                              'range' => 'Dw-1       :   0'
                                            },
                               'm_send_addr_o' => {
                                                    'range' => 'M_Aw-1          :   0',
                                                    'intfc_port' => 'adr_o',
                                                    'intfc_name' => 'plug:wb_master[0]',
                                                    'type' => 'output'
                                                  },
                               's_we_i' => {
                                             'intfc_port' => 'we_i',
                                             'range' => '',
                                             'intfc_name' => 'plug:wb_slave[0]',
                                             'type' => 'input'
                                           },
                               's_addr_i' => {
                                               'range' => 'S_Aw-1     :   0',
                                               'intfc_port' => 'adr_i',
                                               'type' => 'input',
                                               'intfc_name' => 'plug:wb_slave[0]'
                                             },
                               's_ack_o' => {
                                              'type' => 'output',
                                              'intfc_name' => 'plug:wb_slave[0]',
                                              'range' => '',
                                              'intfc_port' => 'ack_o'
                                            },
                               'm_receive_stb_o' => {
                                                      'range' => '',
                                                      'intfc_port' => 'stb_o',
                                                      'intfc_name' => 'plug:wb_master[1]',
                                                      'type' => 'output'
                                                    },
                               's_sel_i' => {
                                              'range' => 'SELw-1     :   0',
                                              'intfc_port' => 'sel_i',
                                              'type' => 'input',
                                              'intfc_name' => 'plug:wb_slave[0]'
                                            },
                               's_cti_i' => {
                                              'intfc_name' => 'plug:wb_slave[0]',
                                              'type' => 'input',
                                              'intfc_port' => 'cti_i',
                                              'range' => 'TAGw-1     :   0'
                                            },
                               'm_send_dat_i' => {
                                                   'intfc_name' => 'plug:wb_master[0]',
                                                   'type' => 'input',
                                                   'range' => 'Dw-1           :  0',
                                                   'intfc_port' => 'dat_i'
                                                 },
                               'm_send_cyc_o' => {
                                                   'range' => '',
                                                   'intfc_port' => 'cyc_o',
                                                   'intfc_name' => 'plug:wb_master[0]',
                                                   'type' => 'output'
                                                 },
                               'm_receive_cti_o' => {
                                                      'intfc_name' => 'plug:wb_master[1]',
                                                      'type' => 'output',
                                                      'intfc_port' => 'cti_o',
                                                      'range' => 'TAGw-1          :   0'
                                                    },
                               'm_send_ack_i' => {
                                                   'type' => 'input',
                                                   'intfc_name' => 'plug:wb_master[0]',
                                                   'intfc_port' => 'ack_i',
                                                   'range' => ''
                                                 },
                               'current_r_addr' => {
                                                     'range' => 'RAw-1   :   0',
                                                     'intfc_port' => 'current_r_addr',
                                                     'type' => 'input',
                                                     'intfc_name' => 'socket:ni[0]'
                                                   },
                               's_stb_i' => {
                                              'range' => '',
                                              'intfc_port' => 'stb_i',
                                              'intfc_name' => 'plug:wb_slave[0]',
                                              'type' => 'input'
                                            }
                             },
                  'unused' => {
                                'plug:wb_slave[0]' => [
                                                        'tag_i',
                                                        'err_o',
                                                        'bte_i',
                                                        'rty_o'
                                                      ],
                                'plug:wb_master[0]' => [
                                                         'rty_i',
                                                         'dat_o',
                                                         'tag_o',
                                                         'err_i',
                                                         'bte_o'
                                                       ],
                                'plug:wb_master[1]' => [
                                                         'dat_i',
                                                         'rty_i',
                                                         'tag_o',
                                                         'err_i',
                                                         'bte_o'
                                                       ]
                              },
                  'parameters_order' => [
                                          'MAX_TRANSACTION_WIDTH',
                                          'MAX_BURST_SIZE',
                                          'Dw',
                                          'S_Aw',
                                          'M_Aw',
                                          'TAGw',
                                          'SELw',
                                          'CRC_EN',
                                          'RAw',
                                          'EAw',
                                          'HDATA_PRECAPw'
                                        ],
                  'module_name' => 'ni_master',
                  'description' => '',
                  'ip_name' => 'ni_master',
                  'hdl_files' => [
                                   '/mpsoc/rtl/src_peripheral/ni/ni_vc_dma.v',
                                   '/mpsoc/rtl/src_peripheral/ni/ni_vc_wb_slave_regs.v',
                                   '/mpsoc/rtl/src_peripheral/ni/ni_master.sv',
                                   '/mpsoc/rtl/src_peripheral/ni/ni_crc32.v',
                                   '/mpsoc/rtl/main_comp.v',
                                   '/mpsoc/rtl/arbiter.v',
								   '/mpsoc/rtl/pronoc_def.v',
                                   '/mpsoc/rtl/src_topology/',
                                   '/mpsoc/rtl/src_noc/'
                                 ],
                  'file_name' => 'mpsoc/rtl/src_peripheral/ni/ni_master.v',
                  'system_c' => '/*
	The NI initializing function. 
	The burst_size must be  <= $MAX_BURST_SIZE
	send_int_en :1: enable the intrrupt when a packet is sent 0 : This intrrupt is disabled
	save_int_en : 1: enable the intrrupt when a recived packet is saved on internal buffer  0 : This intrrupt is disabled
	got_pck_int_en : 1: enable the intrrupt when a packet is recived in NI. 0 : This intrrupt is disabled

*/
void ${IP}_initial (unsigned int burst_size, unsigned char errors_int_en, unsigned char send_done_int_en, unsigned char save_done_int_en, unsigned char got_pck_int_en) {
	${IP}_BURST_SIZE_REG  =  burst_size;
	int i;
	for (i=0; i<${IP}_NUM_VCs;i++){
		if(send_done_int_en)	${IP}_send_done_int_en(i);  else  ${IP}_send_done_int_disable(i);
		if(save_done_int_en)    ${IP}_save_done_int_en(i);  else  ${IP}_save_done_int_disable(i);
		if(got_pck_int_en)      ${IP}_got_pckt_int_en(i);   else  ${IP}_got_pckt_int_disable(i);    
		if(errors_int_en)       ${IP}_error_int_en(i);      else  ${IP}_error_int_disable(i);

	}		
}

/*
	The NI message sent function:
	v: virtual chanel number which this packet should be sent to
	class_num: message class number. Diffrent message classes can be sent via isolated network resources to avoid protocol deadlock
 	data_start_addr : The address pointer to the start location of the packet to be sent in the memory
	data_size: the message data size in words
	dest_phy_addr: the destination endpoint physical address. check phy_adr.h file for knowing each endpoint physical address

*/

void ${IP}_transfer (unsigned int init_weight, unsigned int v, unsigned int class_num, unsigned char  hdr_data, unsigned int data_start_addr,  unsigned int data_size, unsigned int dest_phy_addr){
	while (${IP}_send_is_busy(v)); // wait until VC is busy sending previous packet
        ${IP}_SEND_HDR_DATA_REG(v) = hdr_data;
	${IP}_SEND_DATA_SIZE_REG(v)  = data_size;
	${IP}_SEND_ADDR_POINTER_REG(v)  = data_start_addr;
	${IP}_SEND_DEST_REG(v)   = dest_phy_addr | (class_num<<16) | (init_weight<<24);
	 
}

/*
	The NI message receiver function:
	v: virtual chanel number of the received packet
	data_start_addr : The address pointer to the start location of the memory where the newly arrived packet must be stored by NI in.
	max_buffer_size : The allocated receive-memory buffer size in words.
*/

void ${IP}_receive (unsigned int v, unsigned int data_start_addr,  unsigned int max_buffer_size, unsigned int start_index){
	 while (${IP}_receive_is_busy(v)); // wait until VC is busy saving previous packet
	${IP}_RECEIVE_ADDR_POINTER_REG(v)  = data_start_addr;
        ${IP}_RECEIVE_SATRT_INDEX_REG(v) =   start_index ;
	${IP}_RECEIVE_MAX_BUFF_SIZ_REG(v) = max_buffer_size;
	${IP}_RECEIVE_CTRL_REG(v)   = 1;
}',
                  'system_h' => '#include <stdint.h>
#ifdef MULTI_CORE                  
	#include "../phy_addr.h"
#endif	

/*	    NI wb registers addresses

 VC specefic registers       
       address bits       
 [4+Vw:4]      [3:0]                     
                1  :   CTRL_FLAGS: {invalid_send_req_err, burst_size_err_isr, send_data_size_err_isr, crc_miss_match_isr, rcive_buff_ovrflw_err_isr,got_packet_isr,
                                    packet_is_saved_isr, packet_is_sent_isr,got_any_errorint_en,got_packet_int_en, packet_is_saved_int_en, packet_is_sent_int_en,
                                    receive_is_busy, send_is_busy};                
                2  :   SEND_DEST_WB_ADDR           The destination router address
                3  :   SEND_POINTER_WB_ADDR,       The address of data to be sent in byte 
 Virtual        4  :   SEND_DATA_SIZE_WB_ADDR,     The size of data to be sent in byte  
 chanel        5  :   SEND_HDR_DATA_WB_ADDR       The heder data address
 number        
                8  :   RECEIVE_SRC_WB_ADDR         The source router (the router which is sent this packet).
                9  :   RECEIVE_POINTER_WB_ADDR     The address pointer of reciever memory in byte
                10 :   RECEIVE_DATA_SIZE_WB_ADDR   The size of recieved data in byte
                11 :   RECEIVE_MAX_BUFF_SIZ        The reciver allocated buffer size in words. If the packet size is bigger than the buffer size the rest of ot will be discarred
                12 :   RECEIVE_SATRT_INDEX_WB_ADDR The recived data is wrriten on RECEIVE_POINTER_WB_ADDR + RECEIVE_SATRT_INDEX_WB_ADDR.
                                                       If the write address reach to the end of buffer pointer, it starts at the RECEIVE_POINTER_WB_ADDR.   
                13 :   RECEIVE_CTRL_WB_ADDR        The NI reciever control register 
                14 :   RECEIVE_PRECAP_DATA_ADDR    The address to the header filit data which can be precaptured befor buffering the actual data. 
 
 Shared registers for all VCs
    address bits       
      [5:0]   
       0:    STATUS1_WB_ADDR     // status1:  {send_vc_enable_binary, receive_vc_enable_binary, receive_vc_is_busy, send_vc_is_busy};  
       16:   BURST_SIZE_WB_ADDR  // The busrt size in words        
       32: reserved     
                     
*/



#define COREID	${CORE_ID}
#define CORE_PHY_ADDR   PHY_ADDR_ENDP_${CORE_ID}
#define ${IP}_NUM_VCs	${V}
#define ${IP}_HDATA_PRECAPw     ${HDATA_PRECAPw}
#define ${IP}_BYTE_EN     ${BYTE_EN}  

//general registers
#define ${IP}_STATUS1_REG                 (*((volatile unsigned int *) ($BASE)))   //0
#define ${IP}_BURST_SIZE_REG              (*((volatile unsigned int *) ($BASE+64))) //16

//VC contro registerl 
#define ${IP}_CTRL_FLAGS_REG(v)           (*((volatile unsigned int *) ($BASE+4+(v<<6)))) //1

//Send VC registers
#define ${IP}_SEND_DEST_REG(v)            (*((volatile unsigned int *) ($BASE+8+(v<<6)))) //2
#define ${IP}_SEND_ADDR_POINTER_REG(v)    (*((volatile unsigned int *) ($BASE+12+(v<<6))))  //3
#define ${IP}_SEND_DATA_SIZE_REG(v)       (*((volatile unsigned int *) ($BASE+16+(v<<6))))  //4
#define ${IP}_SEND_HDR_DATA_REG(v)        (*((volatile unsigned int *) ($BASE+20+(v<<6)))) //5

//Receives VC registers
#define ${IP}_RECEIVE_SRC_REG(v)          (*((volatile unsigned int *) ($BASE+32+(v<<6))))  //8
#define ${IP}_RECEIVE_ADDR_POINTER_REG(v) (*((volatile unsigned int *) ($BASE+36+(v<<6)))) //9
#define ${IP}_RECEIVE_DATA_SIZE_REG(v)    (*((volatile unsigned int *) ($BASE+40+(v<<6)))) //10
#define ${IP}_RECEIVE_MAX_BUFF_SIZ_REG(v) (*((volatile unsigned int *) ($BASE+44+(v<<6)))) //11
#define ${IP}_RECEIVE_SATRT_INDEX_REG(v)  (*((volatile unsigned int *) ($BASE+48+(v<<6)))) //12
#define ${IP}_RECEIVE_CTRL_REG(v)         (*((volatile unsigned int *) ($BASE+52+(v<<6)))) //13
#define ${IP}_RECEIVE_PRECAP_DATA_REG(v)  (*((volatile unsigned int *) ($BASE+56+(v<<6)))) //14 

//STATUS FLGs
#define  ANY_SENT_DONE_ISR_FLG    (1<<0)
#define  ANY_SAVE_DONE_ISR_FLG    (1<<1)
#define  ANY_GOT_PCK_ISR_FLG      (1<<2)
#define  ANY_ERR_ISR_FLG           (1<<3)

#define ${IP}_any_sent_done_isr_is_asserted()      (( ${IP}_STATUS1_REG & ANY_SENT_DONE_ISR_FLG )!=0)
#define ${IP}_any_save_done_isr_is_asserted()      (( ${IP}_STATUS1_REG & ANY_SAVE_DONE_ISR_FLG )!=0)
#define ${IP}_any_got_pck_isr_is_asserted()        (( ${IP}_STATUS1_REG & ANY_GOT_PCK_ISR_FLG)!=0)
#define ${IP}_any_err_isr_is_asserted()            (( ${IP}_STATUS1_REG & ANY_ERR_ISR_FLG)!=0)



//CTRL FLGs:
#define SEND_IS_BUSY_FLG         (1<<0)
#define RCV_IS_BUSY_FLG          (1<<1)

#define SEND_DONE_INT_EN_FLG     (1<<2) 
#define SAVE_DONE_INT_EN_FLG     (1<<3) 
#define GOT_PCK_INT_EN_FLG       (1<<4)
#define ANY_ERR_INT_EN_FLG       (1<<5)  

#define SEND_DONE_ISR_FLG        (1<<6) 
#define SAVE_DONE_ISR_FLG        (1<<7) 
#define GOT_PCK_ISR_FLG          (1<<8) 

#define BUFF_OVFLOW_ERR_ISR_FLG  (1<<9)   // This error happens when the receiver allocated buffer size is smaller than the received packet size 
#define CRC_MISS_MATCH_ISR_FLG	 (1<<10)  // This error happens when the received packet CRC miss match
#define SEND_DSIZE_ERR_ISR_FLG   (1<<11)  // This error happens when the send data size is not set  
#define BURST_SIZE_ERR_ISR_FLG	 (1<<12)  // This error happens when the burst size is not set
#define INVALID_SEND_REQ_ISR_FLG (1<<13)  // This error happens when a new send request is received while the DMA is still busy sending previous packet

#define ALL_INT_EN       (SEND_DONE_INT_EN_FLG | SAVE_DONE_INT_EN_FLG | GOT_PCK_INT_EN_FLG | ANY_ERR_INT_EN_FLG)


#define ${IP}_send_is_busy(v)             ((${IP}_CTRL_FLAGS_REG(v) & SEND_IS_BUSY_FLG)!=0)
#define ${IP}_send_is_free(v)             ((${IP}_CTRL_FLAGS_REG(v) & SEND_IS_BUSY_FLG)==0)

#define ${IP}_receive_is_busy(v)          ((${IP}_CTRL_FLAGS_REG(v) & RCV_IS_BUSY_FLG)!=0)
#define ${IP}_receive_is_free(v)          ((${IP}_CTRL_FLAGS_REG(v) & RCV_IS_BUSY_FLG)==0)





#define ${IP}_send_done_int_en(v)	  (${IP}_CTRL_FLAGS_REG(v) |=  SEND_DONE_INT_EN_FLG)
#define ${IP}_send_done_int_disable(v)	  (${IP}_CTRL_FLAGS_REG(v) &= ~SEND_DONE_INT_EN_FLG)
#define ${IP}_save_done_int_en(v)         (${IP}_CTRL_FLAGS_REG(v) |=  SAVE_DONE_INT_EN_FLG)     
#define ${IP}_save_done_int_disable(v) 	  (${IP}_CTRL_FLAGS_REG(v) &= ~SAVE_DONE_INT_EN_FLG)   
#define ${IP}_got_pckt_int_en(v)          (${IP}_CTRL_FLAGS_REG(v) |=  GOT_PCK_INT_EN_FLG)  
#define ${IP}_got_pckt_int_disable(v)     (${IP}_CTRL_FLAGS_REG(v) &= ~GOT_PCK_INT_EN_FLG)      
#define ${IP}_error_int_en(v)             (${IP}_CTRL_FLAGS_REG(v) |=  ANY_ERR_INT_EN_FLG)   
#define ${IP}_error_int_disable(v)        (${IP}_CTRL_FLAGS_REG(v) &= ~ANY_ERR_INT_EN_FLG)    

  

#define ${IP}_packet_is_sent(v)   	  ((${IP}_CTRL_FLAGS_REG(v) & SEND_DONE_ISR_FLG)!=0)
#define ${IP}_packet_is_saved(v)          ((${IP}_CTRL_FLAGS_REG(v) & SAVE_DONE_ISR_FLG )!=0)
#define ${IP}_got_packet(v) 	          ((${IP}_CTRL_FLAGS_REG(v) & GOT_PCK_ISR_FLG)!=0)

#define ${IP}_got_buff_ovf(v)             ((${IP}_CTRL_FLAGS_REG(v) & BUFF_OVFLOW_ERR_ISR_FLG)!=0)
#define ${IP}_got_crc_mismatch(v)         ((${IP}_CTRL_FLAGS_REG(v) & CRC_MISS_MATCH_ISR_FLG)!=0)	 
#define ${IP}_got_send_dsize_err(v)       ((${IP}_CTRL_FLAGS_REG(v) & SEND_DSIZE_ERR_ISR_FLG)!=0)   
#define ${IP}_got_burst_size_err(v)       ((${IP}_CTRL_FLAGS_REG(v) & BURST_SIZE_ERR_ISR_FLG)!=0)	  
#define ${IP}_got_invalid_send_req(v)     ((${IP}_CTRL_FLAGS_REG(v) & INVALID_SEND_REQ_ISR_FLG)!=0) 



//intrrupts ack functions
#define ${IP}_ack_send_done_isr(v)         (${IP}_CTRL_FLAGS_REG(v) &= (ALL_INT_EN | SEND_DONE_ISR_FLG))
#define ${IP}_ack_save_done_isr(v)         (${IP}_CTRL_FLAGS_REG(v) &= (ALL_INT_EN | SAVE_DONE_ISR_FLG))
#define ${IP}_ack_got_pck_isr(v)           (${IP}_CTRL_FLAGS_REG(v) &= (ALL_INT_EN | GOT_PCK_ISR_FLG))

#define ${IP}_ack_buff_ovf_isr(v)          (${IP}_CTRL_FLAGS_REG(v) &= (ALL_INT_EN | BUFF_OVFLOW_ERR_ISR_FLG))  
#define ${IP}_ack_crc_mismatch_isr(v)      (${IP}_CTRL_FLAGS_REG(v) &= (ALL_INT_EN | CRC_MISS_MATCH_ISR_FLG))	 
#define ${IP}_ack_send_dsize_err_isr(v)    (${IP}_CTRL_FLAGS_REG(v) &= (ALL_INT_EN | SEND_DSIZE_ERR_ISR_FLG))   
#define ${IP}_ack_burst_size_err_isr(v)    (${IP}_CTRL_FLAGS_REG(v) &= (ALL_INT_EN | BURST_SIZE_ERR_ISR_FLG))	  
#define ${IP}_ack_invalid_send_req_isr(v)  (${IP}_CTRL_FLAGS_REG(v) &= (ALL_INT_EN | INVALID_SEND_REQ_ISR_FLG))  


#define ${IP}_ack_all_isr(v)  (${IP}_CTRL_FLAGS_REG(v) = ${IP}_CTRL_FLAGS_REG(v))


struct SRC_INFOS{
	unsigned char r; // reserved
	unsigned char c;  // message  class
	int16_t addr; // phy_addr
} ;

static inline struct SRC_INFOS get_src_info(unsigned char v){
	struct SRC_INFOS  src_info =*(struct SRC_INFOS *) (&${IP}_RECEIVE_SRC_REG(v));
	return  src_info;
} 

/*
	The NI initializing function. 
	The burst_size must be  <= $MAX_BURST_SIZE
	send_int_en :1: enable the intrrupt when a packet is sent 0 : This intrrupt is disabled
	save_int_en : 1: enable the intrrupt when a recived packet is saved on internal buffer  0 : This intrrupt is disabled
	got_pck_int_en : 1: enable the intrrupt when a packet is recived in NI. 0 : This intrrupt is disabled

*/
void ${IP}_initial (unsigned int burst_size, unsigned char errors_int_en, unsigned char send_done_int_en, unsigned char save_done_int_en, unsigned char got_pck_int_en) ;

/*
	The NI message sent function:
	v: virtual chanel number which this packet should be sent to
	class_num: message class number. Diffrent message classes can be sent via isolated network resources to avoid protocol deadlock
 	data_start_addr : The address pointer to the start location of the packet to be sent in the memory
	data_size: the message data size in words
	dest_phy_addr: the destination endpoint physical address. check phy_adr.h file for knowing each endpoint physical address

*/

void ${IP}_transfer (unsigned int init_weight, unsigned int v, unsigned int class_num, unsigned char  hdr_data, unsigned int data_start_addr,  unsigned int data_size, unsigned int dest_phy_addr);

/*
	The NI message receiver function:
	v: virtual chanel number of the received packet
	data_start_addr : The address pointer to the start location of the memory where the newly arrived packet must be stored by NI in.
	max_buffer_size : The allocated receive-memory buffer size in words.
*/

void ${IP}_receive (unsigned int v, unsigned int data_start_addr,  unsigned int max_buffer_size, unsigned int start_index);',
                  'gui_status' => {
                                    'status' => 'ideal',
                                    'timeout' => 0
                                  },
                  'system_v' => '`define INCLUDE_TOPOLOGY_LOCALPARAM
    `include "topology_localparam.v"',
                  'modules' => {
                                 'ni_master' => {},
                                 'ovc_status' => {},
                                 'vc_wb_slave_registers' => {},
                                 'ni_vc_dma' => {},
                                 'header_flit_generator' => {}
                               },
                  'version' => 84,
                  'description_pdf' => '/mpsoc/rtl/src_peripheral/ni/NI.pdf',
                  'category' => 'NoC',
                  'sockets' => {
                                 'ni' => {
                                           '0' => {
                                                    'name' => 'ni'
                                                  },
                                           'ni' => {},
                                           'value' => 1,
                                           'connection_num' => 'single connection',
                                           'type' => 'num'
                                         }
                               }
                }, 'ip_gen' );
